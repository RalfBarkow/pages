{
  "title": "Definitions For Oo",
  "story": [
    {
      "type": "html",
      "text": "Many different definitions for [[Object Oriented]] exist; this page catalogs those which carry some weight in the programming (both industry and academic) community. Unfortunately, [[Nobody Agrees On What Oo Is]], a fact used by some to try and discredit OO.",
      "id": "ea540e5482f9614c7b1283c526401808"
    },
    {
      "type": "html",
      "text": "<i>Simple logic says that the definitions below that do not even refer to \"objects\" probably are not <b>truly</b> definitions of OO, no matter what their authors say; instead, some authors may have eroded/hijacked the phrase \"object oriented\" to instead mean \"good post-plain-procedural programming\". [[Robert Cecil Martin]]'s definition below seems especially clearly to be guilty of this.</i>",
      "id": "b1d11bac10ddd37fd3836740c3ab1266"
    },
    {
      "type": "html",
      "text": "<i>Therefore perhaps this page's definitions could be split into two categories for clarity (those that actually refer to objects, and those which do not). However, some claim over-reliance on \"object\" risks a self-referencing (recursive) definitions though.</i>",
      "id": "6b49688f930e603b13edb7c77a058ab3"
    },
    {
      "type": "html",
      "text": "\nThe following definitions of OO are widely cited, and accepted by significant subsets of the community:",
      "id": "7c2fb757c758b40dc9c75c4aa15e1b39"
    },
    {
      "type": "html",
      "text": " The [[Nygaard Classification]]. OO programming is where \"A program execution is regarded as a physical model, simulating the behavior of either a real or imaginary part of the world.\". Many consider this to be the definitive definition; coming from one of the inventors of [[Simula Language]], the first OO language. This definition is the most inclusive - focusing on how a program is <i>modelled</i>, and eschewing any requirements for specific language features (such as found in the other two versions). In the [[Nygaard Classification]], OO-ness can be considered the property of a <i>program</i> rather than a <i>language</i> - it is possible to write Nygaard-OO programs in C or assembler if one chooses. (This doesn't make these languages OO; many choose to disregard the [[Nygaard Classification]] when classifying a <i>language</i> as OO as Nygaard is almost orthogonal to language definition).",
      "id": "a6c80503ceeea41ab2341d50e193968a"
    },
    {
      "type": "html",
      "text": " [[Polymorphism Encapsulation Inheritance]]. Or delegation, if you prefer. This definition seems to have arisen from the C++ community (anyone know the source of this? [[Answer Me]]) - and indeed lists three traits found in many OO languages.  However, counter-examples abound. In many languages (such as [[Python Language]]) encapsulation is by convention rather than enforced by the language; and \"inheritance\" is often replaced with delegation or other means of interface/code reuse between classes/objects. Furthermore, the use of the word \"polymorphism\" in this context isn't quite correct - what is meant is [[Subtype Polymorphism]]; other forms of polymorphism (while welcome) are not what is intended by the definition. (See [[On Understanding Types]]). Use of classes and/or interfaces as explicit object types is often implied in this approach, but it isn't required. ",
      "id": "94d16fc67546252d4c50b88ad010a213"
    },
    {
      "type": "html",
      "text": " [[Alan Kays Definition Of Object Oriented]]. Many in the OO community (particularly users of [[Smalltalk Language]] and its derivatives) consider [[Alan Kay]] to be \"the founder of OO\" and the rightful inventor of the term ([[He Invented The Term]]). While it is undisputed that Simula predated Smalltalk by several years and that Kay was aware of the work on Simula (he acknowledges the work of Nygard and Dahl in his writings), Kay is widely considered to be the first to actually use the term \"OO\" (though Nygaard and Dahl used the term \"object\" in their writings on Simula - see [[He Didnt Invent The Term]]). The Kay definition is the most restrictive, as it excludes many languages (notably [[Cee Plus Plus]] and [[Java Language]], two languages which Kay has bad-mouthed on numerous opportunities) widely considered by others to be OO. Some say this exclusion is intentional, as C++ and Smalltalk competed for developer mindshare through much of the 80s and early 90s; others say that it is justified (based on the claim that C++ is a poor language). ",
      "id": "621094400a9303374e793fa6650551c2"
    },
    {
      "type": "html",
      "text": " Kay's definition includes [[Polymorphism Encapsulation Inheritance]], but adds a few additional requirements:",
      "id": "3a05a2df248c84c237720e89a4c82a12"
    },
    {
      "type": "html",
      "text": " All first-class types must be objects. C++ and Java fail here, as both have types which aren't objects as part of the language.",
      "id": "0d9b644dd04ea3c48c9076962467db7a"
    },
    {
      "type": "html",
      "text": " A singly-rooted inheritance hierarchy. This also trips up C++, which (unique among OO languages) does not have a universal superclass ([[Top Type]]).",
      "id": "7e47b435e92acbd2b17425d0e572085b"
    },
    {
      "type": "html",
      "text": " In addition, Kay has often claimed that [[Static Typing]] is a bad thing, and has written that a good OO language should feature \"late binding in all respects\".  (Which Smalltalk has). Whether or not Kay considers [[Dynamic Typing]] a requirement for OO is unclear.",
      "id": "453d466bee1c91ddec5b4b68e2dc788b"
    },
    {
      "type": "html",
      "text": " [[Robert Cecil Martin]], OO pundit and founder of Object Mentor, says that basically [[Alan Kay]] is wrong, and says that OO is about the [[Dependency Inversion Principle]] (see [[Dependency Inversion]]). To quote, \"I define Object Oriented programming as programming in which abstractions are independent, and concrete modules depend upon them. i.e. Dependency Inversion\" See [http://groups.google.com/groups?hl=en&lr=&ie=UTF-8&oe=UTF-8&threadm=3bb75285.7175698%40news.supernews.com groups.google.com] (Dated 2001-09-30)  He may have changed his mind since going agile, but this view is not necessarily mutually exclusive with agile methodologies.",
      "id": "89a4e2411f0e1fdad510ef917328df45"
    },
    {
      "type": "html",
      "text": " William Cook proposes a modern definition for OO: <i>An object is a first-class, dynamically dispatched behavior. A behavior is a collection of named operations that can be invoked by clients where the operations may share additional hidden details. Dynamic dispatch means that different objects can implement the same operation name(s) in different ways, so the specific operation to be invoked must come from the object identified in the client's request. First class means that objects have the same capabilities as other kinds of values, including being passed to operations or returned as the result of an operation. A language or system is object oriented if it supports the dynamic creation and use of objects. Support means that objects are easy to define and use. It is possible to encode objects in C or Haskell, but an encoding is not support.</i> This definition is further explained at ([http://wcook.blogspot.com/2012/07/proposal-for-simplified-modern.html wcook.blogspot.com]).",
      "id": "436d7ff03aec6394fb32ac25bf6d84b6"
    },
    {
      "type": "html",
      "text": " Re: \"Hidden details\" - This could exclude some dynamic \"OOP\" languages which don't have explicit [[Gate Keeper]] mechanisms.",
      "id": "33086d73acc0e7916453c8fb96d90e6e"
    },
    {
      "type": "html",
      "text": " Luca Cardelli and Martin Abadi developed [[Sigma Calculus]] to model OO, described in the book [[Theory Of Objects]]. While they never outright define OO, they formally address and model elements common to OOP languages: method lookup and dispatch, classes and inheritance, subclasses and specialization, self types, delegation, etc.",
      "id": "b5d3620c55a3aa4f45c359ed55a4907c"
    },
    {
      "type": "html",
      "text": " [[Objects Are Dictionaries]] - maps that can readily contain \"function pointers\" or function containers, with language and/or syntax features that assist in or simplify the usage of these function maps. ",
      "id": "cb512d6915b3cf665a048455d41055b5"
    },
    {
      "type": "html",
      "text": " Variation: \"objects are maps that can map interfaces and/or references to other such maps.\"",
      "id": "9e6671d2cf262a4a2571bcff1c187674"
    },
    {
      "type": "html",
      "text": " OO is the view that [[Everything Isa]] a behavior (including data structures)",
      "id": "2553f9d4a5c65da2fad3afc0507f2dfc"
    },
    {
      "type": "html",
      "text": " OO is the \"natural extension\" of programmer-defined types (sometimes known as user-defined types).",
      "id": "2cf2c2437d284af2e48dedc9d5324b91"
    },
    {
      "type": "html",
      "text": " Inheritance + Encapsulation (no polymorphism): \"Inheritance is what separates abstract data type (ADT) programming from OO programming.\" Section 19.1 of the Feb 2000 Usenet C++ FAQ, which is also published in expanded form in a popular and influential book.  Inheritance without polymorphism, however, is little more than compiler-assisted [[Copy And Paste Programming]]. Useful, but OO?",
      "id": "bf563a9ac7bbde5ae35ffbdfa2a11d4c"
    },
    {
      "type": "html",
      "text": " [[Smug Lisp Weenie]]s define [[Generic Function]]s as [[Object Oriented]], perhaps because [[Closures And Objects Are Equivalent]]. A program is object-oriented when a single function can have many behaviors depending on the types of its arguments.  Some OO languages don't have type overloading, however.  This includes [[Smalltalk Language]]; the only argument to a Smalltalk message which is used to resolve what method should be used is <i>self</i>, giving rise to the [[Double Dispatch]] pattern.",
      "id": "7363a005d17952ff73c92ea49eb338c5"
    },
    {
      "type": "html",
      "text": " [[David Moon]], an old-time Lisp god and writer of much of [[Lisp Machine]] Lisp, defines object-oriented as \"things are independent of their names\".  An OO language is one where as much of the language machinery as possible consist of objects that can be bound to identifiers. Good examples would be Lisp/Dylan/Scheme, with their [[First Class Function]]s/Classes/[[Generic Function]]s/Modules. Bad examples would be C++ and Java, where classes/methods/namespaces are language constructs and can't be passed around in variables.  ",
      "id": "79231f7799d963fe7ea82f7c37a4cb4d"
    },
    {
      "type": "html",
      "text": " Jonathan Rees discusses multiple definitions of OO (see [[Rees On Object Oriented Features]]). In addition to others listed above, he also has",
      "id": "fdd53074de96d879c710127f3fc779bb"
    },
    {
      "type": "html",
      "text": " \"6. All you can do is send a message (AYCDISAM) = [[Actors Model]] - there is no direct manipulation of objects, only communication with (or invocation of) them. The presence of fields in Java violates this.\"",
      "id": "9f21b2ca32142273dc0ea771e7eb6bc9"
    },
    {
      "type": "html",
      "text": " \"9. Sum-of-product-of-function pattern - objects are (in effect) restricted to be functions that take as first argument a distinguished method key argument that is drawn from a finite set of simple names. \"",
      "id": "bd92403599e717bba4b03dd1e1512bd2"
    },
    {
      "type": "html",
      "text": " \"So OO is not a well defined concept. Some people (eg. Abelson and Sussman?) say Lisp is OO, by which they mean {3,4,5,7} (with the proviso that all types are in the programmers' heads). Java is supposed to be OO because of {1,2,3,7,8,9}. E is supposed to be more OO than Java because it has {1,2,3,4,5,7,9} and almost has 6; 8 (subclassing) is seen as antagonistic to E's goals and not necessary for OO.\"",
      "id": "3ae325da2f470e037f65843744af286f"
    },
    {
      "type": "html",
      "text": " '...the C/C++ folks see OO as a liberation from a world that has nothing resembling a first-class functions, while Lisp folks see OO as a prison since it limits their use of functions/objects to the style of (9.)\"",
      "id": "27c4d65f9a43cbb0070d5caaee115c1d"
    },
    {
      "type": "html",
      "text": " Interesting discussion of definitions of \"value\", \"object\", \"function\", and \"type\"",
      "id": "ca0d0179a115f40a8c29bd861c0d1ab3"
    },
    {
      "type": "html",
      "text": " [[Chris Date]] (an RDBMS pundit, and highly influential in that realm): \"An object is essentially just a <i>value</i> (if immutable) or a <i>variable</i> (otherwise).\" (24.1 <i>Introduction to Database Systems</i>) It seems clear that essentially all <b>OO</b> pundits would strongly disagree with that summary, although a lot of Date's discussions of OO <b>databases</b> are more generally reasonable, if still potentially arguable.",
      "id": "474974fa4a1972a3940b9a20893242c3"
    },
    {
      "type": "html",
      "text": " \"Binding Behavior to References\" - Disputed in [[Arguments Against Oop]], where it's stated that OOP is one (or few) of many techniques to manage such references, not the existence of references themselves.",
      "id": "a1f1a51f8ddd905dd96484df8ce18c54"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "91420af28f0cc87808ef59fce9481f67"
    },
    {
      "type": "html",
      "text": "\nClaim:",
      "id": "71fbdcd4d269e411d89cfff70838c1af"
    },
    {
      "type": "html",
      "text": "\n[[Theory Of Objects]] defines object-oriented in terms of [[Lambda Calculus]] and [[Category Theory]]. An object is an unordered record of functions, each with a specific type. See also [[Classes Prototypes Comparison]].",
      "id": "006c90f6064fb95057d898f2dd3f1aeb"
    },
    {
      "type": "html",
      "text": "\nRebuttal: [[Theory Of Objects]] starts off from the very first page by describing object oriented systems pretty much in the exact words as Nigaard (simulating physical model), therefore it is in correct to say that they came up with another definition. Next, they didn't use [[Lambda Calculus]] at all, their thesis and their point in writing the book was that lambda calculus was an inadequate tool to describe properties of object oriented languages so they come up with their own calculi (several) that can be used to reason about object oriented features more effectively. The calculi however do not make a definition, they're just a formalism, a tool if you will.",
      "id": "04073ac37b59c899f054f13806494919"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "91420af28f0cc87808ef59fce9481f67"
    },
    {
      "type": "html",
      "text": "<b>Comments:</b>",
      "id": "2fd0dd366da9a054ea75ca034ef3196f"
    },
    {
      "type": "html",
      "text": "\nRe: <i>Unfortunately, [[Nobody Agrees On What Oo Is]], a fact used by some to try and discredit OO.</i>",
      "id": "af0f59961aec40730c260f308a778a51"
    },
    {
      "type": "html",
      "text": "\nAre you suggesting that is not a mark against it? Or perhaps a small enough mark to not negate its alleged benefits?",
      "id": "3dbc1228c1361459e8462ace9ceba310"
    },
    {
      "type": "html",
      "text": "[<b>I</b> would certainly claim it is not necessarily a mark against it. As I said elsewhere, there's no universal agreement on what \"mathematics\" is, but that doesn't prevent it from being critically useful nor for useful mathematical work to proceed.]",
      "id": "53921b3b57727efe92c974d44cd748a9"
    },
    {
      "type": "html",
      "text": "[Definitional issues are always secondary, and quite often more difficult, than work itself. And note that definitions within math are formally considered to be completely irrelevant. They're like comments.]",
      "id": "6a8ec5b617ceac0d56141782295f1e0e"
    },
    {
      "type": "html",
      "text": "\nOne could argue that excess fuzziness brings about problems because it creates inconsistency and confusion. See [[Oo Lacks Consistency Discussion]].",
      "id": "fd5af6c1901d66fc536ff05934be0713"
    },
    {
      "type": "html",
      "text": "<i>It shows an interesting thing about OO - that the concept(s) of OO came ahead of the formal frameworks and methods which describe OO - the [[Oo Lacks Math]] argument. There have been several mathematical models for OO proposed; [[Theory Of Objects]] has one, the [[Pi Calculus]] is another. None has been accepted as the canonical model to this point. Relational theory, OTOH, is all based on the work of [[Dr Codd]], and [[Functional Programming]] is based on the [[Lambda Calculus]] (actually the lambda </i>calculi<i>, as you have typed- vs untyped- variations).  Now - is the absence of an agreed-upon formal framework harmful? Perhaps; if nothing else a formal framework might help to unify the many different terms, conventions, and technologies in use. Is it fatal to OO? I think not; OO has shown itself to be a valuable paradigm despite the lack of formalism.</i>  ",
      "id": "a350c969c91b05fdee2f4ea9d5037c14"
    },
    {
      "type": "html",
      "text": "\nAs far as implementations, so have Goto's.",
      "id": "a502da7219176cef5df3277b24142901"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "91420af28f0cc87808ef59fce9481f67"
    },
    {
      "type": "html",
      "text": "Are there other principles of object-oriented design than those listed by [[Robert Cecil Martin]], [http://c2.com/cgi/wiki?PrinciplesOfObjectOrientedDesign c2.com]?",
      "id": "e974c51c3bcea53c3cc015b88bbcdce7"
    },
    {
      "type": "html",
      "text": "\nYes! In particular see the list of (often conflicting) [[Definitions For Oo]], including the links (in particular the stuff on paulgraham.com that is linked to was a bit too long to paraphrase on c2.com). I think [[Robert Cecil Martin]] is interesting, and says worthwhile things about software, but truthfully he really annoys me by redefining words. He has an idiosyncratic definition for \"OO\" in particular that no one in the world except his followers share, as mentioned on the cited page. His list on [[Principles Of Object Oriented Design]], on the other hand, is an excellent list, but again, is about software in general, absolutely not about OO in particular; most of it applies perfectly well to old style structured programming in procedural languages. Which reminds me, see the much-neglected yet not obsolete [[Coupling And Cohesion]].  -- dm",
      "id": "80cadf78e77ddc8faf0b6b30386f966d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "91420af28f0cc87808ef59fce9481f67"
    },
    {
      "type": "html",
      "text": "A good definition of OO should probably:",
      "id": "48b8fd73bb2824dfad9ce4700db023da"
    },
    {
      "type": "html",
      "text": " Be applicable to both dynamic and static OO languages.",
      "id": "25ce8491c90ca3c32ec7750d54e177c6"
    },
    {
      "type": "html",
      "text": " Not be defined in terms of other vague or contentious terms (unless defining those first)",
      "id": "398aa011d47a2bdf9bf87b06e28e2175"
    },
    {
      "type": "html",
      "text": " Be relatively short. Long definitions are a sign that more work is needed to extract a higher-abstraction essence.",
      "id": "5f877d76e512d7f1b8d93aa9d327b26e"
    },
    {
      "type": "html",
      "text": " Make it clear whether OO is discrete or continuous. In other words, can something be \"more OO\" than another, and how do we measure.",
      "id": "7162e3029e5f7073338bdb9e6ccecf2b"
    },
    {
      "type": "html",
      "text": " Make it clear whether OO is a mental process or a coding organization technique. If it is both, then make sure both are tied together in the definition.",
      "id": "196d908e53dc3077bbe46894a2ed97eb"
    },
    {
      "type": "html",
      "text": "'''I'm not sure if these goals are possible.  As someone noted before, definitions of OO can conflict with each other--indeed, downright contradict each other--and so it may literally be impossible to reconcile definitions.",
      "id": "d2270aa87436f5dbc582c5b3724915a8"
    },
    {
      "type": "html",
      "text": "\nAs for \"discrete or continuous\", I think the question is almost meaningless--computer science is discrete, after all--but what I think you mean is whether or not it's possible to put an \"order\" on languages.  The answer to that, I think, is a \"qualified yes\":  language A can be more object-oriented than language B, but to complicate matters (taking tinto consideration conflicting definitions, for example) language C might not be comparable to A or B",
      "id": "d802d6a719eec9992a7921aac873e6f3"
    },
    {
      "type": "html",
      "text": " <i>Re: \"computer science is discrete\" - Is this mandatory via universal logic, a historical habit, or something else?</i>",
      "id": "212da7db341379bbbe9b576ea1b477a1"
    },
    {
      "type": "html",
      "text": " <i>Note that if something involves parts, then having only some of the parts can make it \"continuous\" from a perspective. For example, if someone defines OOP as having characteristics A, B, and C; but a given thing has only A and C, then one could make a case that it's \"2/3 OOP\". -t</i>",
      "id": "f6efd5ded636b4ffb685842cafb47dd4"
    },
    {
      "type": "html",
      "text": "\nFinally, OO is clearly a mental process.  There's at least one book about programming OO in Assembly Language; the Linux kernel proudly uses objects in its file system modules, despite being written strictly in C.  Indeed, Lispers like to use closures for OO, and Haskell's type system implements polymorphism in a nice way.",
      "id": "cdae1ef1a4910b1db945233399dd403a"
    },
    {
      "type": "html",
      "text": "\nThis is anagolous to structured programming:  you can write Assembler or BASIC or FORTRAN with beautiful if blocks, while loops, and for loops--but these languages don't have the native keywords, nor the block structure, that makes programming structurally in C so nice!  (And then there are languages like Lisp and Forth, that might not start with trappings for OO, or even structured programming, but you can add those things as you need them.  Smalltalk is almost like this--it starts out with *only* the trappings of OO, and grows from there.)  --Alpheus'''",
      "id": "34babcf90ec199ec2332d8f614c53f47"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "91420af28f0cc87808ef59fce9481f67"
    },
    {
      "type": "html",
      "text": "\nFrom [[Data Centric Thinking]]: ",
      "id": "8bb3da486c0b44ed07245f3c2352afaf"
    },
    {
      "type": "html",
      "text": "\nUnder the [[One Responsibility Rule]] and [[Once And Only Once]], OO programs migrate towards a [[Divide And Conquer]] strategy with configurable delegation: an object will take a big problem, break it into a few smaller problems, <i>delegate</i> the smaller problems, then somehow combine or coordinate the solutions. For example, if part of the problem requires computing a grocery list, you might delegate that problem to an object that happens to be an expert system - though, all you need is a proxy interface that will return your list. The need for delegation creates a need for [[Dependency Injection]]. The fine granularity of objects results naturally from decomposing the problem with a [[Divide And Conquer]] strategy. I suggest: decomposing a difficult solution into smaller objects with dependencies indicates whether you're doing object <b>oriented</b> programming - as opposed to merely programming in the presence of objects.",
      "id": "47f2bb51b31619677132ed72358de25d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "91420af28f0cc87808ef59fce9481f67"
    },
    {
      "type": "html",
      "text": "Related: ",
      "id": "15f59cba92405138fe76279be6f97028"
    },
    {
      "type": "html",
      "text": " [[Classes Prototypes Comparison]]",
      "id": "59faccc5bb7401a09e2addcc84cc9ee0"
    },
    {
      "type": "html",
      "text": " [[Delegation Is Inheritance]]",
      "id": "c521676c97c470a1a042496f4a51ec5c"
    },
    {
      "type": "html",
      "text": " [[Encapsulation Definition]]",
      "id": "619fdee1768f028e21b5b596aa03fb9a"
    },
    {
      "type": "html",
      "text": " [[External Polymorphism]]",
      "id": "c36a029063d583497f35663b94d36818"
    },
    {
      "type": "html",
      "text": " [[Internal Polymorphism]]",
      "id": "d516bb630e8e87e88830d8a9afbbe9a6"
    },
    {
      "type": "html",
      "text": " [[Is Java Object Oriented]]",
      "id": "f84be93d01695215883afc5c90ad572b"
    },
    {
      "type": "html",
      "text": " [[Is Cee Plus Plus Object Oriented]]",
      "id": "010431f95778589977257b923906e6be"
    },
    {
      "type": "html",
      "text": " [[Non Polymorphic Inheritance]]",
      "id": "dcfe4debeb748b77ae2a325da80549b8"
    },
    {
      "type": "html",
      "text": " [[Object Oriented]]",
      "id": "09a4838328caf556410b2129e77413ef"
    },
    {
      "type": "html",
      "text": " [[Polymorphism And Inheritance]]",
      "id": "d5468db1574f7e504ae0bc741db12b8f"
    },
    {
      "type": "html",
      "text": " [[What Is Delegation]]",
      "id": "6254a6e5aa34d8864703d270acfb3ff7"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "91420af28f0cc87808ef59fce9481f67"
    },
    {
      "type": "html",
      "text": "\nI wonder if the reason for all these definitions is, that most of them fail at definining [[What Is An Object]]. At least I was unable to find a definition on [[Object Oriented]], [[Object Oriented Programming]], [[Nygaard Classification]] and others (which led me here). Even the prime example [[Small Talk]] fails at this. Everything is an object, but only in the sense, that it is the core of [[Small Talk]], which is self-referential (the Java \"Object\" is a different object). There seems to be an implied understanding of what an object (in reality or programming is. And this understanding is much too fuzzy, because really [[There Is No Object]]. -- [[Gunnar Zarncke]]",
      "id": "c39343890e6a0a4574a06198002a3cd2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "91420af28f0cc87808ef59fce9481f67"
    },
    {
      "type": "html",
      "text": "I'm reminded of the famous Justice Potter Stewart quote regarding a definition of obscenity:",
      "id": "9d9000e0262dfa3d21d50aa37209a450"
    },
    {
      "type": "html",
      "text": "I shall not today attempt further to define the kinds of material I understand to be embraced within that shorthand description; and perhaps I could never succeed in intelligibly doing so. But I know it when I see it, and the motion picture involved in this case is not that. ([http://caselaw.lp.findlaw.com/scripts/getcase.pl?court=US&vol=378&invol=184 caselaw.lp.findlaw.com])",
      "id": "b144f7d272ad9d9107b3ca9e183e82d8"
    },
    {
      "type": "html",
      "text": "\nI suppose I'm offering a restatement of [[Alan Kays Definition Of Object Oriented]]. I've been doing [[Object Oriented]] development since 1982. I've done it in PDP11 assembler, Lisp, Pascal, C, C++, ObjectiveC, Smalltalk, Java, Javascript, Perl, Python and a gazillion private dialects of one or more of the above. I feel that [[Object Oriented]] programming is therefore something that I can do in virtually any language and system. I therefore find it more interesting to discuss the extent to which a given combination of hardware, software, OS, language, and toolset enhances or impedes my ability to do [[Object Oriented]] development. My own first-hand experience is that C++ absolutely gets in my way, Java is marginally less successful at accomplishing the same goal (of impeding my progress), and Smalltalk, Python and current versions of Javascript (v1.5) help me out -- Smalltalk much more so than either Python or Javascript.",
      "id": "c28b7fe85a52056f716516708b7fa218"
    },
    {
      "type": "html",
      "text": "\nI strongly suspect that this debate about [[Definitions For Oo]] will continue at least as long as [[Definitions For Obscenity]] -- which is approximately forever. In the meantime, Python and Javascript are each widely used, are free of charge, and <b>still</b> lack a variety of tools offered by mainstream Smalltalk environments of a decade ago. I wonder if we might all benefit from spending rather less time perpetuating this endless argument and rather more time figuring out how we might, for example, provide a reasonable, reliable, self-contained debugger/inspector in Javascript that provides the same functionality offered by the Smalltalk debugger <b>twenty five years ago</b> in Smalltalk-80. -- [[Tom Stambaugh]]",
      "id": "a5ee72e9201aef8324df5edd93a48c32"
    },
    {
      "type": "html",
      "text": " <b>But</b>, if you like [[Small Talk]] you know where to find it. It is unfair to criticize OO environments who are successful in the marketplace for lacking all the features of the unsuccessful ones. Maybe it was <b>precisely</b> the everything and the kitchen sink approach that failed, maybe it was something else altogether, but that all that Smalltalk had <b>is</b> actually necessary in Python, Java or Javascript is not at all clear. Maybe ex-smalltalkers miss them, but if somebody could snap his fingers and throw everything in, then you'd have another Smalltalk. So why bother ? Prove that Smalltalk is successful the way it is, or otherwise try to understand why it failed and create the next great Smalltalk. Endlessly complaining along the lines Java is not Smalltalk has been discredited and is not productive. The [[Burden Of Proof]] lies with the Smalltalk community. --[[Costin Cozianu]]'''",
      "id": "a7f79fa743a22fbf082bebb973cc8b1d"
    },
    {
      "type": "html",
      "text": "\nWell said.",
      "id": "f949437bf91ce27bc37ae5a6d24d7337"
    },
    {
      "type": "html",
      "text": "\nOn the other hand, until I participated in constructing material on this page, and seeing the joint results, I was unaware of just how much diversity of opinion was out there. I find this interesting quite independently of the argument about who is right.",
      "id": "596be8586ca6ef50e8dfbe5ae9059f6b"
    },
    {
      "type": "html",
      "text": "\nTo put it another way, I've been mentally interpreting the material on this page as a taxonomy of language types and features, and despite limitations of taxonomies, I find them very useful for multiple purposes. -- [[Doug Merritt]]",
      "id": "64a175eeb43ff4d8caac07012e3d8348"
    },
    {
      "type": "html",
      "text": "\nI feel somehow misunderstood. My point was not to try [[Definitions For Oo]] (that may indeed not be possible), but that ask a somewhat more basic question: [[What Is An Object]]. I know, that probably everyone here has a an understand of what it is (otherwise we couldn't programm OO at all). And I myself have programmed OO in assembly in the 68K micro kernel that was part of my dissertation (creating virtual method dispatch tables with macros). I have an idea of what an object is: [[Memory With Meaning]]. But is it really that? Or how would you define an object? -- .gz",
      "id": "2158f7e799f03dfe29c6b574af68c3fd"
    },
    {
      "type": "html",
      "text": "<i>That's an easy one -- an \"object\" is \"what I do object-oriented programming on\". -- ts</i>",
      "id": "57e21e9d78fb7e9ed8fd3080e3367de5"
    },
    {
      "type": "html",
      "text": "\nThats self-referential, isn't it? Or if it isn't it implies too much. Its like saying \"Wood, thats what a carpenter uses.\" Each [[Programming Paradigm]] may have its own understanding of an object, but there surely are common properties. -- .gz",
      "id": "f4209e9a8001cf012c4fb7de3fe4fa89"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "91420af28f0cc87808ef59fce9481f67"
    },
    {
      "type": "html",
      "text": "\nClaims that OO is the \"original three\" ideas, and attempts to make it more are rubbish:",
      "id": "0c597c19ad79d8f9d5f68726eefbb0f3"
    },
    {
      "type": "html",
      "text": "\n[http://www.tonymarston.net/php-mysql/what-is-oop.html www.tonymarston.net]",
      "id": "38d602539dfcdca34bfdff2e212e975a"
    },
    {
      "type": "html",
      "text": "<i>The funniest sentence:</i>",
      "id": "6e4a5176fe67ae1ba57c4c977a4dc81a"
    },
    {
      "type": "html",
      "text": "<i>\"Having created 1000's of programs using non-OO languages, and another 500+ using the OO features of PHP I feel more than qualified to add my own contribution to the melting pot.\"</i>",
      "id": "c2480923a2ac71ca84336fe7456abc38"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "91420af28f0cc87808ef59fce9481f67"
    },
    {
      "type": "html",
      "text": "Here are my own observations on the definition of OO as drawn from common usage, intent, and usefulness. ",
      "id": "617342cc7ad541edfe5423f72f947b20"
    },
    {
      "type": "html",
      "text": "\nDefinition A- Abstraction, Encapsulation, Data Hiding. Otherwise known as object based. People might commonly refer to this as OO, but most of the time such claims will be retracted when pressed. For example, under these requirements, [[Cee Language]] is OO, and that's not what most people mean when they say OO. ",
      "id": "ae9cd46b60668e7416505769b8f67c27"
    },
    {
      "type": "html",
      "text": " <i>How are you measuring and comparing \"abstraction\"? I keep seeing this viewpoint, but have never seen it defined specifically enough to show that OO has it and other things don't. Yes, OO has a \"flavor\" of abstraction, but not necessarily more abstraction. -t</i>",
      "id": "5a30ef71c2d533b98e5cadd74879ba59"
    },
    {
      "type": "html",
      "text": " I was trying to explain that some people consider object oriented to be programming with objects, where objects is defined as an opaque datum, a thing, a discrete undividable unit of data, with a certain public interface (which may consist of functions and / or public data members). I claim that is not actually what they mean. When made to think about it, people will agree that object orientated programming is not programming with non-polymorphic objects, no matter how well encapsulated, abstracted, and data-hidden.",
      "id": "28894dcc327cefe75dbe87cde0241851"
    },
    {
      "type": "html",
      "text": "\nDynamic Dispatch. This includes the [[Objects Are Dictionaries]] definition. There are collections of data called objects. These objects also have methods which you may call on them. These methods are not resolved statically, but instead depend on the runtime type of the object. This is the message passing description of Smalltalk. In C++ terms, when you call a virtual method, you're not calling a specific function. Instead, you're passing a message to the object, telling it to invoke a method with a certain name. This is the most useful definition of OO IMHO, and generally coincides with what most people consider OO. ",
      "id": "9b919d647522268e09d2d2f231b8eedf"
    },
    {
      "type": "html",
      "text": "\nI reject the \"single inheritance tree\" requirement as not an important quality to what most people call OO. I also reject the modeling definition of OO; you should be able to say a language natively supports OO without looking at common usage of the language. Dynamic dispatch is an objective quality of the language, and it is this quality which most people mean when they say a language natively supports OO. ",
      "id": "2d0116a5023fe680ec3d5fd4d6a26a45"
    },
    {
      "type": "html",
      "text": "\nAlso, it is possible to do OO in languages other than those which natively support OO. You can write the equivalent code of [[Smalltalk Language]] or [[Lisp Language]] in [[Cee Language]]. It would be ugly and mostly impossible to maintain, but it would still be \"OO\". ",
      "id": "746891fb0c63726bfb4f50e142f5c43b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "91420af28f0cc87808ef59fce9481f67"
    },
    {
      "type": "html",
      "text": "Responding to above question where the virtual C++ oriented definition of OO came from, this might be a start.",
      "id": "c52dc31da9fc9824acefab9aff2e4da4"
    },
    {
      "type": "html",
      "text": "\nQuoting: \n[http://www.parashift.com/c++-faq-lite/big-picture.html#faq-6.9 www.parashift.com]\n[http://www.parashift.com/c++-faq-lite/big-picture.html#faq-6.10 www.parashift.com]",
      "id": "8f8f24660a52a38759bf65b97079bf32"
    },
    {
      "type": "html",
      "text": "\nDynamic binding can improve reuse by letting old code call new code. Before OO came along, reuse was accomplished by having new code call old code. For example, a programmer might write some code that called some reusable code such as printf(). With OO, reuse can also be accomplished by having old code call new code. For example, a programmer might write some code that is called by a framework that was written by their great, great grandfather. There's no need to change great-great-grandpa's code. In fact, it doesn't even need to be recompiled. Even if all you have left is the object file and the source code that great-great-grandpa wrote was lost 25 years ago, that ancient object file will call the new extension without anything falling apart. That is extensibility, and that is OO.",
      "id": "520b340c6a421ae0cb7430a6120aa2f4"
    },
    {
      "type": "html",
      "text": "[Jumping to different area in above link for emphasis]",
      "id": "79fa08dca925923663b0803b85c1a418"
    },
    {
      "type": "html",
      "text": "\nBottom line: C++ without virtual is not OO.",
      "id": "02702977cc4c3f2f6cd0edef6385f91b"
    },
    {
      "type": "html",
      "text": "\nEnd quote.",
      "id": "1dc82a95f8fa01c1363d5f490216a863"
    },
    {
      "type": "html",
      "text": "\nThis a disingenuous definition of \"OO\".  To claim that old code could not call new code is absurd!  Besides the obvious example of Lisp, which did these sorts of things pretty much from day one with first-class functions, it's even done in languages like C!  The classical example is that of C's implementation of quicksort, which takes a pointer to an array, and a function that defines an order on the contents of the array, and sorts the array (in place, if I recall correctly).  Even though this implementation was written decades ago, it can sort C++ objects.  -- Alpheus ",
      "id": "9fa2184ad00cefbf128f83db12a69c67"
    },
    {
      "type": "html",
      "text": "<i>While I agree with this assessment in general, please be careful about using words such as \"disingenuous\" without having more background on the person. The author may simply be naive or inadvertently leaving out an assumption that would better qualify their statement. Possilby related: [[Cee Is Not The Pinnacle Of Procedural]].</i>",
      "id": "58c940bee31ce172ae037585dbd693c3"
    },
    {
      "type": "html",
      "text": "{I think \"Alpheus\" must be quite young.  I'll revise the bottom line:  C++ with neither virtual, nor deliberately constructed and inevitably awkward mechanisms to explicitly support old code calling new code, is not OO.}",
      "id": "2903f50116f3b5f7e2eb0a954d0a6c9d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "91420af28f0cc87808ef59fce9481f67"
    },
    {
      "type": "html",
      "text": "[[Category Object Orientation]], [[Category Definition]]",
      "id": "3b73cb8fbbd933c911f1474d0e4ea941"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?DefinitionsForOo c2.com]",
      "id": "106f88e896d34b5c48ef7cd0ea5247c6"
    }
  ],
  "journal": [
    {
      "date": 1416852347000,
      "id": "79307b7b96986e55b50dd8e298072d0f",
      "type": "create",
      "item": {
        "title": "Definitions For Oo",
        "story": [
          {
            "type": "html",
            "text": "Many different definitions for [[Object Oriented]] exist; this page catalogs those which carry some weight in the programming (both industry and academic) community. Unfortunately, [[Nobody Agrees On What Oo Is]], a fact used by some to try and discredit OO.",
            "id": "ea540e5482f9614c7b1283c526401808"
          },
          {
            "type": "html",
            "text": "<i>Simple logic says that the definitions below that do not even refer to \"objects\" probably are not <b>truly</b> definitions of OO, no matter what their authors say; instead, some authors may have eroded/hijacked the phrase \"object oriented\" to instead mean \"good post-plain-procedural programming\". [[Robert Cecil Martin]]'s definition below seems especially clearly to be guilty of this.</i>",
            "id": "b1d11bac10ddd37fd3836740c3ab1266"
          },
          {
            "type": "html",
            "text": "<i>Therefore perhaps this page's definitions could be split into two categories for clarity (those that actually refer to objects, and those which do not). However, some claim over-reliance on \"object\" risks a self-referencing (recursive) definitions though.</i>",
            "id": "6b49688f930e603b13edb7c77a058ab3"
          },
          {
            "type": "html",
            "text": "\nThe following definitions of OO are widely cited, and accepted by significant subsets of the community:",
            "id": "7c2fb757c758b40dc9c75c4aa15e1b39"
          },
          {
            "type": "html",
            "text": " The [[Nygaard Classification]]. OO programming is where \"A program execution is regarded as a physical model, simulating the behavior of either a real or imaginary part of the world.\". Many consider this to be the definitive definition; coming from one of the inventors of [[Simula Language]], the first OO language. This definition is the most inclusive - focusing on how a program is <i>modelled</i>, and eschewing any requirements for specific language features (such as found in the other two versions). In the [[Nygaard Classification]], OO-ness can be considered the property of a <i>program</i> rather than a <i>language</i> - it is possible to write Nygaard-OO programs in C or assembler if one chooses. (This doesn't make these languages OO; many choose to disregard the [[Nygaard Classification]] when classifying a <i>language</i> as OO as Nygaard is almost orthogonal to language definition).",
            "id": "a6c80503ceeea41ab2341d50e193968a"
          },
          {
            "type": "html",
            "text": " [[Polymorphism Encapsulation Inheritance]]. Or delegation, if you prefer. This definition seems to have arisen from the C++ community (anyone know the source of this? [[Answer Me]]) - and indeed lists three traits found in many OO languages.  However, counter-examples abound. In many languages (such as [[Python Language]]) encapsulation is by convention rather than enforced by the language; and \"inheritance\" is often replaced with delegation or other means of interface/code reuse between classes/objects. Furthermore, the use of the word \"polymorphism\" in this context isn't quite correct - what is meant is [[Subtype Polymorphism]]; other forms of polymorphism (while welcome) are not what is intended by the definition. (See [[On Understanding Types]]). Use of classes and/or interfaces as explicit object types is often implied in this approach, but it isn't required. ",
            "id": "94d16fc67546252d4c50b88ad010a213"
          },
          {
            "type": "html",
            "text": " [[Alan Kays Definition Of Object Oriented]]. Many in the OO community (particularly users of [[Smalltalk Language]] and its derivatives) consider [[Alan Kay]] to be \"the founder of OO\" and the rightful inventor of the term ([[He Invented The Term]]). While it is undisputed that Simula predated Smalltalk by several years and that Kay was aware of the work on Simula (he acknowledges the work of Nygard and Dahl in his writings), Kay is widely considered to be the first to actually use the term \"OO\" (though Nygaard and Dahl used the term \"object\" in their writings on Simula - see [[He Didnt Invent The Term]]). The Kay definition is the most restrictive, as it excludes many languages (notably [[Cee Plus Plus]] and [[Java Language]], two languages which Kay has bad-mouthed on numerous opportunities) widely considered by others to be OO. Some say this exclusion is intentional, as C++ and Smalltalk competed for developer mindshare through much of the 80s and early 90s; others say that it is justified (based on the claim that C++ is a poor language). ",
            "id": "621094400a9303374e793fa6650551c2"
          },
          {
            "type": "html",
            "text": " Kay's definition includes [[Polymorphism Encapsulation Inheritance]], but adds a few additional requirements:",
            "id": "3a05a2df248c84c237720e89a4c82a12"
          },
          {
            "type": "html",
            "text": " All first-class types must be objects. C++ and Java fail here, as both have types which aren't objects as part of the language.",
            "id": "0d9b644dd04ea3c48c9076962467db7a"
          },
          {
            "type": "html",
            "text": " A singly-rooted inheritance hierarchy. This also trips up C++, which (unique among OO languages) does not have a universal superclass ([[Top Type]]).",
            "id": "7e47b435e92acbd2b17425d0e572085b"
          },
          {
            "type": "html",
            "text": " In addition, Kay has often claimed that [[Static Typing]] is a bad thing, and has written that a good OO language should feature \"late binding in all respects\".  (Which Smalltalk has). Whether or not Kay considers [[Dynamic Typing]] a requirement for OO is unclear.",
            "id": "453d466bee1c91ddec5b4b68e2dc788b"
          },
          {
            "type": "html",
            "text": " [[Robert Cecil Martin]], OO pundit and founder of Object Mentor, says that basically [[Alan Kay]] is wrong, and says that OO is about the [[Dependency Inversion Principle]] (see [[Dependency Inversion]]). To quote, \"I define Object Oriented programming as programming in which abstractions are independent, and concrete modules depend upon them. i.e. Dependency Inversion\" See [http://groups.google.com/groups?hl=en&lr=&ie=UTF-8&oe=UTF-8&threadm=3bb75285.7175698%40news.supernews.com groups.google.com] (Dated 2001-09-30)  He may have changed his mind since going agile, but this view is not necessarily mutually exclusive with agile methodologies.",
            "id": "89a4e2411f0e1fdad510ef917328df45"
          },
          {
            "type": "html",
            "text": " William Cook proposes a modern definition for OO: <i>An object is a first-class, dynamically dispatched behavior. A behavior is a collection of named operations that can be invoked by clients where the operations may share additional hidden details. Dynamic dispatch means that different objects can implement the same operation name(s) in different ways, so the specific operation to be invoked must come from the object identified in the client's request. First class means that objects have the same capabilities as other kinds of values, including being passed to operations or returned as the result of an operation. A language or system is object oriented if it supports the dynamic creation and use of objects. Support means that objects are easy to define and use. It is possible to encode objects in C or Haskell, but an encoding is not support.</i> This definition is further explained at ([http://wcook.blogspot.com/2012/07/proposal-for-simplified-modern.html wcook.blogspot.com]).",
            "id": "436d7ff03aec6394fb32ac25bf6d84b6"
          },
          {
            "type": "html",
            "text": " Re: \"Hidden details\" - This could exclude some dynamic \"OOP\" languages which don't have explicit [[Gate Keeper]] mechanisms.",
            "id": "33086d73acc0e7916453c8fb96d90e6e"
          },
          {
            "type": "html",
            "text": " Luca Cardelli and Martin Abadi developed [[Sigma Calculus]] to model OO, described in the book [[Theory Of Objects]]. While they never outright define OO, they formally address and model elements common to OOP languages: method lookup and dispatch, classes and inheritance, subclasses and specialization, self types, delegation, etc.",
            "id": "b5d3620c55a3aa4f45c359ed55a4907c"
          },
          {
            "type": "html",
            "text": " [[Objects Are Dictionaries]] - maps that can readily contain \"function pointers\" or function containers, with language and/or syntax features that assist in or simplify the usage of these function maps. ",
            "id": "cb512d6915b3cf665a048455d41055b5"
          },
          {
            "type": "html",
            "text": " Variation: \"objects are maps that can map interfaces and/or references to other such maps.\"",
            "id": "9e6671d2cf262a4a2571bcff1c187674"
          },
          {
            "type": "html",
            "text": " OO is the view that [[Everything Isa]] a behavior (including data structures)",
            "id": "2553f9d4a5c65da2fad3afc0507f2dfc"
          },
          {
            "type": "html",
            "text": " OO is the \"natural extension\" of programmer-defined types (sometimes known as user-defined types).",
            "id": "2cf2c2437d284af2e48dedc9d5324b91"
          },
          {
            "type": "html",
            "text": " Inheritance + Encapsulation (no polymorphism): \"Inheritance is what separates abstract data type (ADT) programming from OO programming.\" Section 19.1 of the Feb 2000 Usenet C++ FAQ, which is also published in expanded form in a popular and influential book.  Inheritance without polymorphism, however, is little more than compiler-assisted [[Copy And Paste Programming]]. Useful, but OO?",
            "id": "bf563a9ac7bbde5ae35ffbdfa2a11d4c"
          },
          {
            "type": "html",
            "text": " [[Smug Lisp Weenie]]s define [[Generic Function]]s as [[Object Oriented]], perhaps because [[Closures And Objects Are Equivalent]]. A program is object-oriented when a single function can have many behaviors depending on the types of its arguments.  Some OO languages don't have type overloading, however.  This includes [[Smalltalk Language]]; the only argument to a Smalltalk message which is used to resolve what method should be used is <i>self</i>, giving rise to the [[Double Dispatch]] pattern.",
            "id": "7363a005d17952ff73c92ea49eb338c5"
          },
          {
            "type": "html",
            "text": " [[David Moon]], an old-time Lisp god and writer of much of [[Lisp Machine]] Lisp, defines object-oriented as \"things are independent of their names\".  An OO language is one where as much of the language machinery as possible consist of objects that can be bound to identifiers. Good examples would be Lisp/Dylan/Scheme, with their [[First Class Function]]s/Classes/[[Generic Function]]s/Modules. Bad examples would be C++ and Java, where classes/methods/namespaces are language constructs and can't be passed around in variables.  ",
            "id": "79231f7799d963fe7ea82f7c37a4cb4d"
          },
          {
            "type": "html",
            "text": " Jonathan Rees discusses multiple definitions of OO (see [[Rees On Object Oriented Features]]). In addition to others listed above, he also has",
            "id": "fdd53074de96d879c710127f3fc779bb"
          },
          {
            "type": "html",
            "text": " \"6. All you can do is send a message (AYCDISAM) = [[Actors Model]] - there is no direct manipulation of objects, only communication with (or invocation of) them. The presence of fields in Java violates this.\"",
            "id": "9f21b2ca32142273dc0ea771e7eb6bc9"
          },
          {
            "type": "html",
            "text": " \"9. Sum-of-product-of-function pattern - objects are (in effect) restricted to be functions that take as first argument a distinguished method key argument that is drawn from a finite set of simple names. \"",
            "id": "bd92403599e717bba4b03dd1e1512bd2"
          },
          {
            "type": "html",
            "text": " \"So OO is not a well defined concept. Some people (eg. Abelson and Sussman?) say Lisp is OO, by which they mean {3,4,5,7} (with the proviso that all types are in the programmers' heads). Java is supposed to be OO because of {1,2,3,7,8,9}. E is supposed to be more OO than Java because it has {1,2,3,4,5,7,9} and almost has 6; 8 (subclassing) is seen as antagonistic to E's goals and not necessary for OO.\"",
            "id": "3ae325da2f470e037f65843744af286f"
          },
          {
            "type": "html",
            "text": " '...the C/C++ folks see OO as a liberation from a world that has nothing resembling a first-class functions, while Lisp folks see OO as a prison since it limits their use of functions/objects to the style of (9.)\"",
            "id": "27c4d65f9a43cbb0070d5caaee115c1d"
          },
          {
            "type": "html",
            "text": " Interesting discussion of definitions of \"value\", \"object\", \"function\", and \"type\"",
            "id": "ca0d0179a115f40a8c29bd861c0d1ab3"
          },
          {
            "type": "html",
            "text": " [[Chris Date]] (an RDBMS pundit, and highly influential in that realm): \"An object is essentially just a <i>value</i> (if immutable) or a <i>variable</i> (otherwise).\" (24.1 <i>Introduction to Database Systems</i>) It seems clear that essentially all <b>OO</b> pundits would strongly disagree with that summary, although a lot of Date's discussions of OO <b>databases</b> are more generally reasonable, if still potentially arguable.",
            "id": "474974fa4a1972a3940b9a20893242c3"
          },
          {
            "type": "html",
            "text": " \"Binding Behavior to References\" - Disputed in [[Arguments Against Oop]], where it's stated that OOP is one (or few) of many techniques to manage such references, not the existence of references themselves.",
            "id": "a1f1a51f8ddd905dd96484df8ce18c54"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "91420af28f0cc87808ef59fce9481f67"
          },
          {
            "type": "html",
            "text": "\nClaim:",
            "id": "71fbdcd4d269e411d89cfff70838c1af"
          },
          {
            "type": "html",
            "text": "\n[[Theory Of Objects]] defines object-oriented in terms of [[Lambda Calculus]] and [[Category Theory]]. An object is an unordered record of functions, each with a specific type. See also [[Classes Prototypes Comparison]].",
            "id": "006c90f6064fb95057d898f2dd3f1aeb"
          },
          {
            "type": "html",
            "text": "\nRebuttal: [[Theory Of Objects]] starts off from the very first page by describing object oriented systems pretty much in the exact words as Nigaard (simulating physical model), therefore it is in correct to say that they came up with another definition. Next, they didn't use [[Lambda Calculus]] at all, their thesis and their point in writing the book was that lambda calculus was an inadequate tool to describe properties of object oriented languages so they come up with their own calculi (several) that can be used to reason about object oriented features more effectively. The calculi however do not make a definition, they're just a formalism, a tool if you will.",
            "id": "04073ac37b59c899f054f13806494919"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "91420af28f0cc87808ef59fce9481f67"
          },
          {
            "type": "html",
            "text": "<b>Comments:</b>",
            "id": "2fd0dd366da9a054ea75ca034ef3196f"
          },
          {
            "type": "html",
            "text": "\nRe: <i>Unfortunately, [[Nobody Agrees On What Oo Is]], a fact used by some to try and discredit OO.</i>",
            "id": "af0f59961aec40730c260f308a778a51"
          },
          {
            "type": "html",
            "text": "\nAre you suggesting that is not a mark against it? Or perhaps a small enough mark to not negate its alleged benefits?",
            "id": "3dbc1228c1361459e8462ace9ceba310"
          },
          {
            "type": "html",
            "text": "[<b>I</b> would certainly claim it is not necessarily a mark against it. As I said elsewhere, there's no universal agreement on what \"mathematics\" is, but that doesn't prevent it from being critically useful nor for useful mathematical work to proceed.]",
            "id": "53921b3b57727efe92c974d44cd748a9"
          },
          {
            "type": "html",
            "text": "[Definitional issues are always secondary, and quite often more difficult, than work itself. And note that definitions within math are formally considered to be completely irrelevant. They're like comments.]",
            "id": "6a8ec5b617ceac0d56141782295f1e0e"
          },
          {
            "type": "html",
            "text": "\nOne could argue that excess fuzziness brings about problems because it creates inconsistency and confusion. See [[Oo Lacks Consistency Discussion]].",
            "id": "fd5af6c1901d66fc536ff05934be0713"
          },
          {
            "type": "html",
            "text": "<i>It shows an interesting thing about OO - that the concept(s) of OO came ahead of the formal frameworks and methods which describe OO - the [[Oo Lacks Math]] argument. There have been several mathematical models for OO proposed; [[Theory Of Objects]] has one, the [[Pi Calculus]] is another. None has been accepted as the canonical model to this point. Relational theory, OTOH, is all based on the work of [[Dr Codd]], and [[Functional Programming]] is based on the [[Lambda Calculus]] (actually the lambda </i>calculi<i>, as you have typed- vs untyped- variations).  Now - is the absence of an agreed-upon formal framework harmful? Perhaps; if nothing else a formal framework might help to unify the many different terms, conventions, and technologies in use. Is it fatal to OO? I think not; OO has shown itself to be a valuable paradigm despite the lack of formalism.</i>  ",
            "id": "a350c969c91b05fdee2f4ea9d5037c14"
          },
          {
            "type": "html",
            "text": "\nAs far as implementations, so have Goto's.",
            "id": "a502da7219176cef5df3277b24142901"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "91420af28f0cc87808ef59fce9481f67"
          },
          {
            "type": "html",
            "text": "Are there other principles of object-oriented design than those listed by [[Robert Cecil Martin]], [http://c2.com/cgi/wiki?PrinciplesOfObjectOrientedDesign c2.com]?",
            "id": "e974c51c3bcea53c3cc015b88bbcdce7"
          },
          {
            "type": "html",
            "text": "\nYes! In particular see the list of (often conflicting) [[Definitions For Oo]], including the links (in particular the stuff on paulgraham.com that is linked to was a bit too long to paraphrase on c2.com). I think [[Robert Cecil Martin]] is interesting, and says worthwhile things about software, but truthfully he really annoys me by redefining words. He has an idiosyncratic definition for \"OO\" in particular that no one in the world except his followers share, as mentioned on the cited page. His list on [[Principles Of Object Oriented Design]], on the other hand, is an excellent list, but again, is about software in general, absolutely not about OO in particular; most of it applies perfectly well to old style structured programming in procedural languages. Which reminds me, see the much-neglected yet not obsolete [[Coupling And Cohesion]].  -- dm",
            "id": "80cadf78e77ddc8faf0b6b30386f966d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "91420af28f0cc87808ef59fce9481f67"
          },
          {
            "type": "html",
            "text": "A good definition of OO should probably:",
            "id": "48b8fd73bb2824dfad9ce4700db023da"
          },
          {
            "type": "html",
            "text": " Be applicable to both dynamic and static OO languages.",
            "id": "25ce8491c90ca3c32ec7750d54e177c6"
          },
          {
            "type": "html",
            "text": " Not be defined in terms of other vague or contentious terms (unless defining those first)",
            "id": "398aa011d47a2bdf9bf87b06e28e2175"
          },
          {
            "type": "html",
            "text": " Be relatively short. Long definitions are a sign that more work is needed to extract a higher-abstraction essence.",
            "id": "5f877d76e512d7f1b8d93aa9d327b26e"
          },
          {
            "type": "html",
            "text": " Make it clear whether OO is discrete or continuous. In other words, can something be \"more OO\" than another, and how do we measure.",
            "id": "7162e3029e5f7073338bdb9e6ccecf2b"
          },
          {
            "type": "html",
            "text": " Make it clear whether OO is a mental process or a coding organization technique. If it is both, then make sure both are tied together in the definition.",
            "id": "196d908e53dc3077bbe46894a2ed97eb"
          },
          {
            "type": "html",
            "text": "'''I'm not sure if these goals are possible.  As someone noted before, definitions of OO can conflict with each other--indeed, downright contradict each other--and so it may literally be impossible to reconcile definitions.",
            "id": "d2270aa87436f5dbc582c5b3724915a8"
          },
          {
            "type": "html",
            "text": "\nAs for \"discrete or continuous\", I think the question is almost meaningless--computer science is discrete, after all--but what I think you mean is whether or not it's possible to put an \"order\" on languages.  The answer to that, I think, is a \"qualified yes\":  language A can be more object-oriented than language B, but to complicate matters (taking tinto consideration conflicting definitions, for example) language C might not be comparable to A or B",
            "id": "d802d6a719eec9992a7921aac873e6f3"
          },
          {
            "type": "html",
            "text": " <i>Re: \"computer science is discrete\" - Is this mandatory via universal logic, a historical habit, or something else?</i>",
            "id": "212da7db341379bbbe9b576ea1b477a1"
          },
          {
            "type": "html",
            "text": " <i>Note that if something involves parts, then having only some of the parts can make it \"continuous\" from a perspective. For example, if someone defines OOP as having characteristics A, B, and C; but a given thing has only A and C, then one could make a case that it's \"2/3 OOP\". -t</i>",
            "id": "f6efd5ded636b4ffb685842cafb47dd4"
          },
          {
            "type": "html",
            "text": "\nFinally, OO is clearly a mental process.  There's at least one book about programming OO in Assembly Language; the Linux kernel proudly uses objects in its file system modules, despite being written strictly in C.  Indeed, Lispers like to use closures for OO, and Haskell's type system implements polymorphism in a nice way.",
            "id": "cdae1ef1a4910b1db945233399dd403a"
          },
          {
            "type": "html",
            "text": "\nThis is anagolous to structured programming:  you can write Assembler or BASIC or FORTRAN with beautiful if blocks, while loops, and for loops--but these languages don't have the native keywords, nor the block structure, that makes programming structurally in C so nice!  (And then there are languages like Lisp and Forth, that might not start with trappings for OO, or even structured programming, but you can add those things as you need them.  Smalltalk is almost like this--it starts out with *only* the trappings of OO, and grows from there.)  --Alpheus'''",
            "id": "34babcf90ec199ec2332d8f614c53f47"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "91420af28f0cc87808ef59fce9481f67"
          },
          {
            "type": "html",
            "text": "\nFrom [[Data Centric Thinking]]: ",
            "id": "8bb3da486c0b44ed07245f3c2352afaf"
          },
          {
            "type": "html",
            "text": "\nUnder the [[One Responsibility Rule]] and [[Once And Only Once]], OO programs migrate towards a [[Divide And Conquer]] strategy with configurable delegation: an object will take a big problem, break it into a few smaller problems, <i>delegate</i> the smaller problems, then somehow combine or coordinate the solutions. For example, if part of the problem requires computing a grocery list, you might delegate that problem to an object that happens to be an expert system - though, all you need is a proxy interface that will return your list. The need for delegation creates a need for [[Dependency Injection]]. The fine granularity of objects results naturally from decomposing the problem with a [[Divide And Conquer]] strategy. I suggest: decomposing a difficult solution into smaller objects with dependencies indicates whether you're doing object <b>oriented</b> programming - as opposed to merely programming in the presence of objects.",
            "id": "47f2bb51b31619677132ed72358de25d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "91420af28f0cc87808ef59fce9481f67"
          },
          {
            "type": "html",
            "text": "Related: ",
            "id": "15f59cba92405138fe76279be6f97028"
          },
          {
            "type": "html",
            "text": " [[Classes Prototypes Comparison]]",
            "id": "59faccc5bb7401a09e2addcc84cc9ee0"
          },
          {
            "type": "html",
            "text": " [[Delegation Is Inheritance]]",
            "id": "c521676c97c470a1a042496f4a51ec5c"
          },
          {
            "type": "html",
            "text": " [[Encapsulation Definition]]",
            "id": "619fdee1768f028e21b5b596aa03fb9a"
          },
          {
            "type": "html",
            "text": " [[External Polymorphism]]",
            "id": "c36a029063d583497f35663b94d36818"
          },
          {
            "type": "html",
            "text": " [[Internal Polymorphism]]",
            "id": "d516bb630e8e87e88830d8a9afbbe9a6"
          },
          {
            "type": "html",
            "text": " [[Is Java Object Oriented]]",
            "id": "f84be93d01695215883afc5c90ad572b"
          },
          {
            "type": "html",
            "text": " [[Is Cee Plus Plus Object Oriented]]",
            "id": "010431f95778589977257b923906e6be"
          },
          {
            "type": "html",
            "text": " [[Non Polymorphic Inheritance]]",
            "id": "dcfe4debeb748b77ae2a325da80549b8"
          },
          {
            "type": "html",
            "text": " [[Object Oriented]]",
            "id": "09a4838328caf556410b2129e77413ef"
          },
          {
            "type": "html",
            "text": " [[Polymorphism And Inheritance]]",
            "id": "d5468db1574f7e504ae0bc741db12b8f"
          },
          {
            "type": "html",
            "text": " [[What Is Delegation]]",
            "id": "6254a6e5aa34d8864703d270acfb3ff7"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "91420af28f0cc87808ef59fce9481f67"
          },
          {
            "type": "html",
            "text": "\nI wonder if the reason for all these definitions is, that most of them fail at definining [[What Is An Object]]. At least I was unable to find a definition on [[Object Oriented]], [[Object Oriented Programming]], [[Nygaard Classification]] and others (which led me here). Even the prime example [[Small Talk]] fails at this. Everything is an object, but only in the sense, that it is the core of [[Small Talk]], which is self-referential (the Java \"Object\" is a different object). There seems to be an implied understanding of what an object (in reality or programming is. And this understanding is much too fuzzy, because really [[There Is No Object]]. -- [[Gunnar Zarncke]]",
            "id": "c39343890e6a0a4574a06198002a3cd2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "91420af28f0cc87808ef59fce9481f67"
          },
          {
            "type": "html",
            "text": "I'm reminded of the famous Justice Potter Stewart quote regarding a definition of obscenity:",
            "id": "9d9000e0262dfa3d21d50aa37209a450"
          },
          {
            "type": "html",
            "text": "I shall not today attempt further to define the kinds of material I understand to be embraced within that shorthand description; and perhaps I could never succeed in intelligibly doing so. But I know it when I see it, and the motion picture involved in this case is not that. ([http://caselaw.lp.findlaw.com/scripts/getcase.pl?court=US&vol=378&invol=184 caselaw.lp.findlaw.com])",
            "id": "b144f7d272ad9d9107b3ca9e183e82d8"
          },
          {
            "type": "html",
            "text": "\nI suppose I'm offering a restatement of [[Alan Kays Definition Of Object Oriented]]. I've been doing [[Object Oriented]] development since 1982. I've done it in PDP11 assembler, Lisp, Pascal, C, C++, ObjectiveC, Smalltalk, Java, Javascript, Perl, Python and a gazillion private dialects of one or more of the above. I feel that [[Object Oriented]] programming is therefore something that I can do in virtually any language and system. I therefore find it more interesting to discuss the extent to which a given combination of hardware, software, OS, language, and toolset enhances or impedes my ability to do [[Object Oriented]] development. My own first-hand experience is that C++ absolutely gets in my way, Java is marginally less successful at accomplishing the same goal (of impeding my progress), and Smalltalk, Python and current versions of Javascript (v1.5) help me out -- Smalltalk much more so than either Python or Javascript.",
            "id": "c28b7fe85a52056f716516708b7fa218"
          },
          {
            "type": "html",
            "text": "\nI strongly suspect that this debate about [[Definitions For Oo]] will continue at least as long as [[Definitions For Obscenity]] -- which is approximately forever. In the meantime, Python and Javascript are each widely used, are free of charge, and <b>still</b> lack a variety of tools offered by mainstream Smalltalk environments of a decade ago. I wonder if we might all benefit from spending rather less time perpetuating this endless argument and rather more time figuring out how we might, for example, provide a reasonable, reliable, self-contained debugger/inspector in Javascript that provides the same functionality offered by the Smalltalk debugger <b>twenty five years ago</b> in Smalltalk-80. -- [[Tom Stambaugh]]",
            "id": "a5ee72e9201aef8324df5edd93a48c32"
          },
          {
            "type": "html",
            "text": " <b>But</b>, if you like [[Small Talk]] you know where to find it. It is unfair to criticize OO environments who are successful in the marketplace for lacking all the features of the unsuccessful ones. Maybe it was <b>precisely</b> the everything and the kitchen sink approach that failed, maybe it was something else altogether, but that all that Smalltalk had <b>is</b> actually necessary in Python, Java or Javascript is not at all clear. Maybe ex-smalltalkers miss them, but if somebody could snap his fingers and throw everything in, then you'd have another Smalltalk. So why bother ? Prove that Smalltalk is successful the way it is, or otherwise try to understand why it failed and create the next great Smalltalk. Endlessly complaining along the lines Java is not Smalltalk has been discredited and is not productive. The [[Burden Of Proof]] lies with the Smalltalk community. --[[Costin Cozianu]]'''",
            "id": "a7f79fa743a22fbf082bebb973cc8b1d"
          },
          {
            "type": "html",
            "text": "\nWell said.",
            "id": "f949437bf91ce27bc37ae5a6d24d7337"
          },
          {
            "type": "html",
            "text": "\nOn the other hand, until I participated in constructing material on this page, and seeing the joint results, I was unaware of just how much diversity of opinion was out there. I find this interesting quite independently of the argument about who is right.",
            "id": "596be8586ca6ef50e8dfbe5ae9059f6b"
          },
          {
            "type": "html",
            "text": "\nTo put it another way, I've been mentally interpreting the material on this page as a taxonomy of language types and features, and despite limitations of taxonomies, I find them very useful for multiple purposes. -- [[Doug Merritt]]",
            "id": "64a175eeb43ff4d8caac07012e3d8348"
          },
          {
            "type": "html",
            "text": "\nI feel somehow misunderstood. My point was not to try [[Definitions For Oo]] (that may indeed not be possible), but that ask a somewhat more basic question: [[What Is An Object]]. I know, that probably everyone here has a an understand of what it is (otherwise we couldn't programm OO at all). And I myself have programmed OO in assembly in the 68K micro kernel that was part of my dissertation (creating virtual method dispatch tables with macros). I have an idea of what an object is: [[Memory With Meaning]]. But is it really that? Or how would you define an object? -- .gz",
            "id": "2158f7e799f03dfe29c6b574af68c3fd"
          },
          {
            "type": "html",
            "text": "<i>That's an easy one -- an \"object\" is \"what I do object-oriented programming on\". -- ts</i>",
            "id": "57e21e9d78fb7e9ed8fd3080e3367de5"
          },
          {
            "type": "html",
            "text": "\nThats self-referential, isn't it? Or if it isn't it implies too much. Its like saying \"Wood, thats what a carpenter uses.\" Each [[Programming Paradigm]] may have its own understanding of an object, but there surely are common properties. -- .gz",
            "id": "f4209e9a8001cf012c4fb7de3fe4fa89"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "91420af28f0cc87808ef59fce9481f67"
          },
          {
            "type": "html",
            "text": "\nClaims that OO is the \"original three\" ideas, and attempts to make it more are rubbish:",
            "id": "0c597c19ad79d8f9d5f68726eefbb0f3"
          },
          {
            "type": "html",
            "text": "\n[http://www.tonymarston.net/php-mysql/what-is-oop.html www.tonymarston.net]",
            "id": "38d602539dfcdca34bfdff2e212e975a"
          },
          {
            "type": "html",
            "text": "<i>The funniest sentence:</i>",
            "id": "6e4a5176fe67ae1ba57c4c977a4dc81a"
          },
          {
            "type": "html",
            "text": "<i>\"Having created 1000's of programs using non-OO languages, and another 500+ using the OO features of PHP I feel more than qualified to add my own contribution to the melting pot.\"</i>",
            "id": "c2480923a2ac71ca84336fe7456abc38"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "91420af28f0cc87808ef59fce9481f67"
          },
          {
            "type": "html",
            "text": "Here are my own observations on the definition of OO as drawn from common usage, intent, and usefulness. ",
            "id": "617342cc7ad541edfe5423f72f947b20"
          },
          {
            "type": "html",
            "text": "\nDefinition A- Abstraction, Encapsulation, Data Hiding. Otherwise known as object based. People might commonly refer to this as OO, but most of the time such claims will be retracted when pressed. For example, under these requirements, [[Cee Language]] is OO, and that's not what most people mean when they say OO. ",
            "id": "ae9cd46b60668e7416505769b8f67c27"
          },
          {
            "type": "html",
            "text": " <i>How are you measuring and comparing \"abstraction\"? I keep seeing this viewpoint, but have never seen it defined specifically enough to show that OO has it and other things don't. Yes, OO has a \"flavor\" of abstraction, but not necessarily more abstraction. -t</i>",
            "id": "5a30ef71c2d533b98e5cadd74879ba59"
          },
          {
            "type": "html",
            "text": " I was trying to explain that some people consider object oriented to be programming with objects, where objects is defined as an opaque datum, a thing, a discrete undividable unit of data, with a certain public interface (which may consist of functions and / or public data members). I claim that is not actually what they mean. When made to think about it, people will agree that object orientated programming is not programming with non-polymorphic objects, no matter how well encapsulated, abstracted, and data-hidden.",
            "id": "28894dcc327cefe75dbe87cde0241851"
          },
          {
            "type": "html",
            "text": "\nDynamic Dispatch. This includes the [[Objects Are Dictionaries]] definition. There are collections of data called objects. These objects also have methods which you may call on them. These methods are not resolved statically, but instead depend on the runtime type of the object. This is the message passing description of Smalltalk. In C++ terms, when you call a virtual method, you're not calling a specific function. Instead, you're passing a message to the object, telling it to invoke a method with a certain name. This is the most useful definition of OO IMHO, and generally coincides with what most people consider OO. ",
            "id": "9b919d647522268e09d2d2f231b8eedf"
          },
          {
            "type": "html",
            "text": "\nI reject the \"single inheritance tree\" requirement as not an important quality to what most people call OO. I also reject the modeling definition of OO; you should be able to say a language natively supports OO without looking at common usage of the language. Dynamic dispatch is an objective quality of the language, and it is this quality which most people mean when they say a language natively supports OO. ",
            "id": "2d0116a5023fe680ec3d5fd4d6a26a45"
          },
          {
            "type": "html",
            "text": "\nAlso, it is possible to do OO in languages other than those which natively support OO. You can write the equivalent code of [[Smalltalk Language]] or [[Lisp Language]] in [[Cee Language]]. It would be ugly and mostly impossible to maintain, but it would still be \"OO\". ",
            "id": "746891fb0c63726bfb4f50e142f5c43b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "91420af28f0cc87808ef59fce9481f67"
          },
          {
            "type": "html",
            "text": "Responding to above question where the virtual C++ oriented definition of OO came from, this might be a start.",
            "id": "c52dc31da9fc9824acefab9aff2e4da4"
          },
          {
            "type": "html",
            "text": "\nQuoting: \n[http://www.parashift.com/c++-faq-lite/big-picture.html#faq-6.9 www.parashift.com]\n[http://www.parashift.com/c++-faq-lite/big-picture.html#faq-6.10 www.parashift.com]",
            "id": "8f8f24660a52a38759bf65b97079bf32"
          },
          {
            "type": "html",
            "text": "\nDynamic binding can improve reuse by letting old code call new code. Before OO came along, reuse was accomplished by having new code call old code. For example, a programmer might write some code that called some reusable code such as printf(). With OO, reuse can also be accomplished by having old code call new code. For example, a programmer might write some code that is called by a framework that was written by their great, great grandfather. There's no need to change great-great-grandpa's code. In fact, it doesn't even need to be recompiled. Even if all you have left is the object file and the source code that great-great-grandpa wrote was lost 25 years ago, that ancient object file will call the new extension without anything falling apart. That is extensibility, and that is OO.",
            "id": "520b340c6a421ae0cb7430a6120aa2f4"
          },
          {
            "type": "html",
            "text": "[Jumping to different area in above link for emphasis]",
            "id": "79fa08dca925923663b0803b85c1a418"
          },
          {
            "type": "html",
            "text": "\nBottom line: C++ without virtual is not OO.",
            "id": "02702977cc4c3f2f6cd0edef6385f91b"
          },
          {
            "type": "html",
            "text": "\nEnd quote.",
            "id": "1dc82a95f8fa01c1363d5f490216a863"
          },
          {
            "type": "html",
            "text": "\nThis a disingenuous definition of \"OO\".  To claim that old code could not call new code is absurd!  Besides the obvious example of Lisp, which did these sorts of things pretty much from day one with first-class functions, it's even done in languages like C!  The classical example is that of C's implementation of quicksort, which takes a pointer to an array, and a function that defines an order on the contents of the array, and sorts the array (in place, if I recall correctly).  Even though this implementation was written decades ago, it can sort C++ objects.  -- Alpheus ",
            "id": "9fa2184ad00cefbf128f83db12a69c67"
          },
          {
            "type": "html",
            "text": "<i>While I agree with this assessment in general, please be careful about using words such as \"disingenuous\" without having more background on the person. The author may simply be naive or inadvertently leaving out an assumption that would better qualify their statement. Possilby related: [[Cee Is Not The Pinnacle Of Procedural]].</i>",
            "id": "58c940bee31ce172ae037585dbd693c3"
          },
          {
            "type": "html",
            "text": "{I think \"Alpheus\" must be quite young.  I'll revise the bottom line:  C++ with neither virtual, nor deliberately constructed and inevitably awkward mechanisms to explicitly support old code calling new code, is not OO.}",
            "id": "2903f50116f3b5f7e2eb0a954d0a6c9d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "91420af28f0cc87808ef59fce9481f67"
          },
          {
            "type": "html",
            "text": "[[Category Object Orientation]], [[Category Definition]]",
            "id": "3b73cb8fbbd933c911f1474d0e4ea941"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?DefinitionsForOo c2.com]",
            "id": "106f88e896d34b5c48ef7cd0ea5247c6"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1705486655288
    }
  ]
}