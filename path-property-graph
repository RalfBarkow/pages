{
  "title": "Path Property Graph",
  "story": [
    {
      "type": "paragraph",
      "id": "d52c6a8bb146e466",
      "text": "A Path Property Graph (PPG) is an edge and node labeled graph where edges and nodes additionally have property-value pairs. In addition, a PPG may also have a collection of paths, where a path is a concatenation of existing, adjacent, edges in the graph."
    },
    {
      "type": "pagefold",
      "id": "f211091881c6bc7e",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "903f829d0b846113",
      "text": "URZUA, Valentina and GUTIERREZ, Claudio, [no date]. Linear Recursion in G-CORE."
    },
    {
      "type": "markdown",
      "id": "f1c9ef1253104bb0",
      "text": "> G-CORE is a query language with two key characteristics: It is closed under graphs and incoporates paths as ﬁrst-class citizens. Currently G-CORE does not have recursion. In this paper we propose this extension and show how to code classical polynomial graph algorithms with it.\n"
    },
    {
      "type": "paragraph",
      "id": "0ca31a4bfa89e34e",
      "text": "Adding recursion to database query languages has been extensively studied both from a theoretical [3] as well as from a practical point of view (e.g. SQL, SPARQL [4, 5]). In SQL it was included in the SQL-99 standard and was developed via common table expressions (CTE'S) that have a base SELECT statement and a recursive SELECT statement, that allows to express graph queries like DFS, BFS, topological sort, connected components, etc. Since queries must be linear and many interesting queries are not [6], optimizations have been proposed in [7, 8] (r-sql proposal) that allow only linear recursion and not the explicit negation that is a limitation when implementing recursion [3]. "
    },
    {
      "type": "paragraph",
      "id": "1ea9e1f6176473eb",
      "text": "The graph algorithms BFS and DFS were implemented in [9] with the recursive SQL operator, where only trees were allowed as input since otherwise the query would loop infinitely. The topological order was studied in [10], making a BFS starting from the node whose outdegree is zero. In the case of the connected components it is shown in [11] how to obtain them adding recursion. "
    },
    {
      "type": "paragraph",
      "id": "0702ab7a5990c5e5",
      "text": "For SPARQL, Reutter et al [5] proposed a recursion operator based on SQL and make a comparison with property paths. In their study they formalize the syntax of the recursive operator and develop algorithms for evaluating it in practical scenarios. Also, a comparative study of the expressiveness of property paths and the recursive SQL operator was made in [6]."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Path Property Graph",
        "story": []
      },
      "date": 1664793501559
    },
    {
      "item": {
        "type": "factory",
        "id": "d52c6a8bb146e466"
      },
      "id": "d52c6a8bb146e466",
      "type": "add",
      "date": 1664793503370
    },
    {
      "item": {
        "type": "factory",
        "id": "f211091881c6bc7e"
      },
      "id": "f211091881c6bc7e",
      "type": "add",
      "after": "d52c6a8bb146e466",
      "date": 1664793505203
    },
    {
      "type": "edit",
      "id": "f211091881c6bc7e",
      "item": {
        "type": "pagefold",
        "id": "f211091881c6bc7e",
        "text": "~"
      },
      "date": 1664793508737
    },
    {
      "item": {
        "type": "factory",
        "id": "903f829d0b846113"
      },
      "id": "903f829d0b846113",
      "type": "add",
      "after": "f211091881c6bc7e",
      "date": 1664793510862
    },
    {
      "type": "edit",
      "id": "903f829d0b846113",
      "item": {
        "type": "paragraph",
        "id": "903f829d0b846113",
        "text": "\nURZUA, Valentina and GUTIERREZ, Claudio, [no date]. Linear Recursion in G-CORE. . P. 5. G-CORE is a query language with two key characteristics: It is closed under graphs and incoporates paths as ﬁrst-class citizens. Currently G-CORE does not have recursion. In this paper we propose this extension and show how to code classical polynomial graph algorithms with it.\n"
      },
      "date": 1664793519669
    },
    {
      "type": "edit",
      "id": "d52c6a8bb146e466",
      "item": {
        "type": "paragraph",
        "id": "d52c6a8bb146e466",
        "text": "A Path Property Graph (PPG) is an edge and node labeled graph where edges and nodes additionally have property-value pairs. In addition, a PPG may also have a collection of paths, where a path is a concatenation of existing, adjacent, edges in the graph."
      },
      "date": 1664793618786
    },
    {
      "type": "edit",
      "id": "903f829d0b846113",
      "item": {
        "type": "paragraph",
        "id": "903f829d0b846113",
        "text": "URZUA, Valentina and GUTIERREZ, Claudio, [no date]. Linear Recursion in G-CORE. . P. 5. "
      },
      "date": 1664793642173
    },
    {
      "type": "add",
      "id": "f1c9ef1253104bb0",
      "item": {
        "type": "paragraph",
        "id": "f1c9ef1253104bb0",
        "text": "> G-CORE is a query language with two key characteristics: It is closed under graphs and incoporates paths as ﬁrst-class citizens. Currently G-CORE does not have recursion. In this paper we propose this extension and show how to code classical polynomial graph algorithms with it.\n"
      },
      "after": "903f829d0b846113",
      "date": 1664793643852
    },
    {
      "type": "edit",
      "id": "f1c9ef1253104bb0",
      "item": {
        "type": "markdown",
        "id": "f1c9ef1253104bb0",
        "text": "> G-CORE is a query language with two key characteristics: It is closed under graphs and incoporates paths as ﬁrst-class citizens. Currently G-CORE does not have recursion. In this paper we propose this extension and show how to code classical polynomial graph algorithms with it.\n"
      },
      "date": 1664793644906
    },
    {
      "type": "edit",
      "id": "903f829d0b846113",
      "item": {
        "type": "paragraph",
        "id": "903f829d0b846113",
        "text": "URZUA, Valentina and GUTIERREZ, Claudio, [no date]. Linear Recursion in G-CORE."
      },
      "date": 1664793649935
    },
    {
      "item": {
        "type": "factory",
        "id": "0ca31a4bfa89e34e"
      },
      "id": "0ca31a4bfa89e34e",
      "type": "add",
      "after": "f1c9ef1253104bb0",
      "date": 1664793684314
    },
    {
      "type": "edit",
      "id": "0ca31a4bfa89e34e",
      "item": {
        "type": "paragraph",
        "id": "0ca31a4bfa89e34e",
        "text": "Adding recursion to database query languages has been extensively studied both from a theoretical [3] as well as from a practical point of view (e.g. SQL, SPARQL [4, 5]). In SQL it was included in the SQL-99 standard and was developed via common table expressions (CTE'S) that have a base SELECT statement and a recursive SELECT statement, that allows to express graph queries like DFS, BFS, topological sort, connected components, etc. Since queries must be linear and many interesting queries are not [6], optimizations have been proposed in [7, 8] (r-sql proposal) that allow only linear recursion and not the explicit negation that is a limitation when implementing recursion [3]. The graph algorithms BFS and DFS were implemented in [9] with the recursive SQL operator, where only trees were allowed as input since otherwise the query would loop infinitely. The topological order was studied in [10], making a BFS starting from the node whose outdegree is zero. In the case of the connected components it is shown in [11] how to obtain them adding recursion. For SPARQL, Reutter et al [5] proposed a recursion operator based on SQL and make a comparison with property paths. In their study they formalize the syntax of the recursive operator and develop algorithms for evaluating it in practical scenarios. Also, a comparative study of the expressiveness of property paths and the recursive SQL operator was made in [6]."
      },
      "date": 1664793687947
    },
    {
      "type": "edit",
      "id": "0ca31a4bfa89e34e",
      "item": {
        "type": "paragraph",
        "id": "0ca31a4bfa89e34e",
        "text": "Adding recursion to database query languages has been extensively studied both from a theoretical [3] as well as from a practical point of view (e.g. SQL, SPARQL [4, 5]). In SQL it was included in the SQL-99 standard and was developed via common table expressions (CTE'S) that have a base SELECT statement and a recursive SELECT statement, that allows to express graph queries like DFS, BFS, topological sort, connected components, etc. Since queries must be linear and many interesting queries are not [6], optimizations have been proposed in [7, 8] (r-sql proposal) that allow only linear recursion and not the explicit negation that is a limitation when implementing recursion [3]. "
      },
      "date": 1664793725599
    },
    {
      "type": "add",
      "id": "1ea9e1f6176473eb",
      "item": {
        "type": "paragraph",
        "id": "1ea9e1f6176473eb",
        "text": "The graph algorithms BFS and DFS were implemented in [9] with the recursive SQL operator, where only trees were allowed as input since otherwise the query would loop infinitely. The topological order was studied in [10], making a BFS starting from the node whose outdegree is zero. In the case of the connected components it is shown in [11] how to obtain them adding recursion. For SPARQL, Reutter et al [5] proposed a recursion operator based on SQL and make a comparison with property paths. In their study they formalize the syntax of the recursive operator and develop algorithms for evaluating it in practical scenarios. Also, a comparative study of the expressiveness of property paths and the recursive SQL operator was made in [6]."
      },
      "after": "0ca31a4bfa89e34e",
      "date": 1664793725987
    },
    {
      "type": "edit",
      "id": "1ea9e1f6176473eb",
      "item": {
        "type": "paragraph",
        "id": "1ea9e1f6176473eb",
        "text": "The graph algorithms BFS and DFS were implemented in [9] with the recursive SQL operator, where only trees were allowed as input since otherwise the query would loop infinitely. The topological order was studied in [10], making a BFS starting from the node whose outdegree is zero. In the case of the connected components it is shown in [11] how to obtain them adding recursion. "
      },
      "date": 1664793739205
    },
    {
      "type": "add",
      "id": "0702ab7a5990c5e5",
      "item": {
        "type": "paragraph",
        "id": "0702ab7a5990c5e5",
        "text": "For SPARQL, Reutter et al [5] proposed a recursion operator based on SQL and make a comparison with property paths. In their study they formalize the syntax of the recursive operator and develop algorithms for evaluating it in practical scenarios. Also, a comparative study of the expressiveness of property paths and the recursive SQL operator was made in [6]."
      },
      "after": "1ea9e1f6176473eb",
      "date": 1664793740216
    }
  ]
}